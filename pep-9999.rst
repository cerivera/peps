PEP: 9999
Title: Pattern matching
Version: $Revision$
Last-Modified: $Date$
Author: Ivan Levkivskyi <levkivskyi@gmail.com>
BDFL-Delegate:
Discussions-To: Python-Dev <python-dev@python.org>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 2020-05-04
Python version: 3.10
Resolution:

Abstract
========

This PEP proposes to add pattern matching statements [1]_ to Python. This will
allow more readable and reliable code when dealing with well structured
heterogeneous data. The PEP contains syntax specification, runtime
specification, and recommended specification for static type checkers.

Previously PEP 275 and PEP 3101 that proposed similar constructs were
rejected. Here we take a different approach and focus on generalizing
iterable and dictionary unpacking instead just syntax-sugaring and optimizing
``if ... elif ... else`` statement. Also, recently implemented PEP 617
introduced a new PEG parser for Python now allows more flexible syntactic
options.


Rationale and Goals
===================

Let us start from some anecdotal evidence: ``isinstance()`` is one of the most
called functions in large scale Python code-bases by static call count.
In particular, when analyzing some multi-million line production code base,
it was discovered that ``isinstance()`` is the second mast called builtin
function (after ``len()``). Even taking into account builtin classes, it is
still in the top ten.

There are two possible conclusions that can be made from this information:

* Handling of heterogeneous data (i.e. situations where a variable can take
  values of multiple types) is common in real world code.

* Python doesn't have expressive ways of destructuring data (i.e. separating
  the content of an object into multiple variables).

This is in contrast with the opposite sides of both aspects:

* Its success in the numeric world indicates that Python is good when
  working with homogeneous data. It also has builtin support for homogeneous
  data structures such as e.g. lists and arrays, and semantic constructs such
  as iterators and generators.

* Python is expressive and flexible at constructing object. It has syntactic
  support for collection literals and comprehensions. Custom objects can be
  created using positional and keyword calls that are customized by special
  ``__init__()`` method.

This PEP aims at improving the support for destructuring heterogeneous data
by adding a dedicated syntactic support for it in the form of pattern matching.
On very high level it is similar to regular expressions, but instead of
matching string, it will be possible to match arbitrary Python objects.

We believe this will improve both readability and reliability of relevant code.
To illustrate the readability improvement, let us consider an actual example
from the Python standard library::

  def is_tuple(node):
      if isinstance(node, Node) and node.children == [LParen(), RParen()]:
          return True
      return (isinstance(node, Node)
              and len(node.children) == 3
              and isinstance(node.children[0], Leaf)
              and isinstance(node.children[1], Node)
              and isinstance(node.children[2], Leaf)
              and node.children[0].value == "("
              and node.children[2].value == ")")

With the syntax proposed in this PEP it can be rewritten as below. Note that
the proposed code will work without any modifications to the definition of
``Node`` and other classes here::

  def is_tuple(node: Node) -> bool:
      match node:
      as Node(children=[LParen(), RParen()]):
      as Node(children=[Leaf(value="("), Node(...), Leaf(value=")")]):
          return True
      else:
          return False

See the `syntax`_ sections below for a more detailed specification. From
the reliability perspective, experience shows that missing a case when dealing
with a set of possible data values leads to hard to debug issues, thus forcing
people to add safety asserts like this::

  def get_first(data: Union[int, List[int]]) -> int:
      if isinstance(data, list) and data:
          return data[0]
      elif isinstance(data, int):
          return data
      else:
          assert False, "should never get here"

With the proposed pattern matching such exhaustiveness checks will be added
automatically.

Similar to how constructing objects can be customized by user defined
``__init__()`` method, we propose that destructuring objects can be customized
by a new special ``__match__()`` method. As part of this PEP we specify the
builtin implementations for ``object.__match__()``, for builtin collections
such as ``tuple``, ``list``, ``dict``, and ``set``, and for auto-generated
flexible ``__match__()`` method for PEP 557 dataclasses. See `runtime`_
section below.

Finally, we aim to provide a comprehensive support for static type checkers
and similar tools. For this purpose we propose to introduce a
``@typing.sealed`` class decorator that will be idempotent at runtime, but
will indicate to static tools that all subclasses of this class must be defined
in the same module. This will allow effective static exhaustiveness checks,
and together with dataclasses, will provide a nice support for algebraic data
types [2]_. See `static checkers`_ section for more details.

In general, we believe that pattern matching proved to be a useful and
expressive tool in various modern languages. In particular, some aspects of
this PEP were inspired by how pattern matches work in Rust [3]_ and
Scala [4]_.


.. _syntax:

Syntax and Semantics
====================

Match arms
----------

A simplified pseudo-grammar for the proposed syntax is::

    Match = "match" Expression ":" (("as" Pattern ":")+ Suite)+ ["else:" Suite]

We propose the match syntax to be a statement, not expression. Although in
many languages it is an expression, being a statement better suites the general
logic of Python syntax. See `rejected ideas`_ for more discussion. The list of
allowed patterns is specified below in the `patterns`_ subsection.

The ``match`` word is proposed to be a soft keyword, so that it is recognized
as a keyword at the beginning of match statement, but is allowed to be used in
other positions as a variable or argument name.

Note that there can be more than one match arm per match suite. The proposed
indentation structure is as following::

    match some_expression:
    as pattern_1a:
    as pattern_1b:
        ...
    as pattern_2:
        ...
    else:
        ...

Such layout saves an indentation level and matches a common indentation scheme
for ``switch`` statement in C language. Although this may be tricky for some
simple-minded editors, it should be not hard to support in principle, one just
needs to not add indentation level after a colon if the previous line starts
with ``match``.


Match semantics
---------------

The proposed large scale semantics for choosing the match is to choose first
matching pattern and and execute the corresponding suite. The remaining
patterns are not tried. If there are no matching pattens, the ``else`` clause
is executed. If the latter is absent, an instance of ``UnmatchedValue``
(proposed to be a subclass of ``ValueError``) is raised.

Essentially this is equivalent to a chain of ``if ... elif ... else`` except
the default ``else`` clause is to raise an exception. Note that unlike for
``switch`` statement, the pre-computed dispatch dictionary semantics does not
apply here.

Name bindings made during successful pattern match outlive the executed suite
and can be used after the match statement. This follows the logic of other
Python statements that can bind names, such as ``for`` loop and ``with``
statement. For example::

  match shape:
  as Point(x, y):
      ...
  as Rectangle(x, y, _x, _y):
      ...
  print(x, y)  # This works


.. _patterns:

Allowed patterns
----------------

The following patterns are supported:

* Literal pattern, i.e. a simple literal like a string, a number, boolean,
  or None::

    match number:
    as 1:
        print("Just one")
    as 2:
        print("A couple")
    else:
        print("Many")

  Literal pattern uses equality with literal on the right hand side, so that
  in the above example ``number == 1`` and then possibly ``number == 2`` will
  be evaluated.

* Name pattern, that serves as an assignment target for the matched
  expression::

  match greeting:
  as None:
      print("Hello!")
  as name:
      print(f"Hi {name}!")

* Display pattern is a generalization of iterable unpacking but supports all
  builtin collections: tuples, lists, dictionaries, and sets. Each element
  can be an arbitrary pattern plus there may be at most one ``*name`` or
  ``**name`` pattern to catch all remaining elements::

    match collection:
    as (1, x, *other):
        print("Got tuple")
    as [1, [x, *other]]:
        print("Got nested list")
    as {1: x, **other}:
        print("Got dictionary")
    else:
        print("Probably a set")

  For dictionaries and sets the order of items is ignored, so e.g. the result
  of matching ``{1, 2}`` against ``{x, y}`` is unpredictable, but the latter
  will only match a set with two elements. Under the hood these matches will
  use the ``__match__()`` protocol as specified in `runtime`_ section.

* Unstructured class pattern is a synonym for an ``isinstance()`` check, it is
  mostly useful in nested positions, when the content of the object is not
  important and it serves just as a marker. For example::

    match shapes:
    as [Point(...), second, third, *other]:
        print(f"Hm, the first one is point, then {second} and {third}")

* Structured class pattern supports two possible ways of matching: by position
  like ``Point(x, y)``, and by name like ``User(id=id, name=name)``. These two
  can be combined, but positional match cannot follow a match by name. Each
  item in a class match can be an arbitrary pattern, plus at most one ``*name``
  or ``**name`` pattern can be present. Semantics of the class pattern is an
  ``isinstance()`` call plus a ``__match__()`` call on the class if the former
  returns ``True``. For example::

    match shape:
    as Point(x, y):
        ...
    as Rectangle(*coordinates, painted=True):
        ...

  This PEP only fully specifies the behavior ``__match__()``
  for builtins and dataclasses, custom classes are only required to follow
  protocol specified in `runtime`_ section. After all, the authors of a class
  know best how to "revert" the logic of the ``__init__()`` they wrote. The
  runtime will then chain these calls to allow matching against arbitrarily
  nested patterns.


Guards
------

Name is bound after guard succeed. Needed in particular because we
don't have constants.


Matching names
--------------

Compared by chained (not pairwise) equality for every group.

Named sub-patterns
------------------

For example::

  match get_shape():
  as Line(point := Point(x, y), point):
      print(f"Zero length line at {x}, {y}")

Another example::

  match group_shapes():
  as ([], [point := Point(x, y), *other]):
      print(f"Got {point} in the second group")
      ...


Ad-hoc matches
--------------

Python is pragmatic -> ad-hoc special-casing::

  if isinstance(node, CallExpr):
      if (isinstance(node.callee, NameExpr) and len(node.args) == 1 and
              isinstance(node.args[0], NameExpr)):
          call = node.callee.name
          arg = node.args[0].name
          ...  # Continue special-casing
  ...  # Follow with generic code

This can be rewritten as::

  if match node as CallExpr(callee=NameExpr(name=call), args=[NameExpr(name=arg)]):
      ...  # Continue special-casing
  ...  # Follow with generic code


Important: no guards. Similar for ``while match``::

  def get_next_data() -> Union[Chunk, Timeout]:
      ...

  while match get_next_data() as Chunk(data, checksum=0):
      ...  # Do stuff with data


.. _runtime:

Runtime specification
=====================

The ``__match__()`` protocol
----------------------------


Impossible matches
-------------------


Default ``object.__match__()``
------------------------------


Dataclasses
-----------


Builtin classes
---------------


.. _static checkers:

Static checkers specification
=============================

Exhaustiveness checks
---------------------


Sealed classes as ADTs
----------------------


Type erasure
------------


Note about constants
--------------------


Backwards Compatibility
=======================

This PEP is fully backwards compatible.


Reference Implementation
========================

None yet.


.. _rejected ideas:

Rejected Ideas
==============

Just allow a more flexible assignment targets
---------------------------------------------

No, because it is not what is commonly needed, people want an ``if``.


Make it an expression
---------------------

No, because it is inconsistent with other things in Python


Use a hard keyword
------------------

Although it would significantly simplify life for simple No, because:

* The new parser doesn't require us to do this.

* ``match`` is so commonly used in existing code


Use a nested indentation scheme
-------------------------------

No, because it can be really long for nested match statements.


Use ``or`` to combine matches
-----------------------------

No, because:

* Can cause ambiguity with guards, also with other operators like ``|``.

* In real life it will be anyway split over multiple lines.

* Using multiple arms is not uncommon in other languages.


Support constant pattern
------------------------

No, because it is too ambiguous. Also use ``if x == BLACK: ...``.


Use dispatch dict semantics for matches
---------------------------------------

Because it may be very tricky if possible at all (unlike for switch
statement).


Allow fall through without a match
----------------------------------

No, because:

* This can cause subtle bugs.

* It is easy to add an ``else`` match arm.

* Use ad-hoc matches for special cases.


Allow ``elif match`` statements
-------------------------------

No, because there should be only one way to do it. If people will ask about
this, we can always reconsider later.


Allow arbitrary expressions in reference matches
------------------------------------------------

No, because:

* May be syntactically tricky

* Keep it clean/simple

* The meaning of a pattern is primarily left hand side (like for iterable
  unpacking), let us keep it that way.


Use ``__getitem__()`` and ``__getstate__()`` as fallback
--------------------------------------------------------

No, because:

* May be surprising.

* Inconsistent with current way unpacking works.


Ignore underscores in coinciding name match
-------------------------------------------

No, because this is subtle and may be unexpected, instead use ``_1``, ``_2``
etc.


Implement builtin support for matches on ``frozenset``
------------------------------------------------------

No, because supporting this may require complicating the basic
syntax/semantics and this will be probably used very rarely. We can
reconsider if people will actually ask about this.


References
==========

.. [1]
   https://en.wikipedia.org/wiki/Pattern_matching

.. [2]
   https://en.wikipedia.org/wiki/Algebraic_data_type

.. [3]
   https://doc.rust-lang.org/reference/patterns.html

.. [4]
   https://docs.scala-lang.org/tour/pattern-matching.html

.. [5]
   https://docs.python.org/3/library/dataclasses.html

.. [6]
   https://docs.python.org/3/library/typing.html


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
