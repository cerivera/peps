PEP: 9999
Title: Pattern matching
Version: $Revision$
Last-Modified: $Date$
Author: Ivan Levkivskyi <levkivskyi@gmail.com>
BDFL-Delegate:
Discussions-To: Python-Dev <python-dev@python.org>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 2020-05-04
Python version: 3.10
Resolution:

Abstract
========

This PEP proposes to add pattern matching statements [1]_ to Python. This will
allow more readable and reliable code when dealing with well structured
heterogeneous data. The PEP takes a holistic approach and contains syntax
specification, runtime specification, and recommended specification for static
type checkers.

Previously PEP 275 and PEP 3101 that proposed similar constructs were
rejected. Here we choose a different approach and focus on generalizing
iterable and dictionary unpacking instead just syntax-sugaring and optimizing
``if ... elif ... else`` statement. Also, recently implemented PEP 617
introduced a new PEG parser for Python now allows more flexible syntactic
options.


Rationale and Goals
===================

Let us start from some anecdotal evidence: ``isinstance()`` is one of the most
called functions in large scale Python code-bases by static call count.
In particular, when analyzing some multi-million line production code base,
it was discovered that ``isinstance()`` is the second mast called builtin
function (after ``len()``). Even taking into account builtin classes, it is
still in the top ten.

There are two possible conclusions that can be made from this information:

* Handling of heterogeneous data (i.e. situations where a variable can take
  values of multiple types) is common in real world code.

* Python doesn't have expressive ways of destructuring data (i.e. separating
  the content of an object into multiple variables).

This is in contrast with the opposite sides of both aspects:

* Its success in the numeric world indicates that Python is good when
  working with homogeneous data. It also has builtin support for homogeneous
  data structures such as e.g. lists and arrays, and semantic constructs such
  as iterators and generators.

* Python is expressive and flexible at constructing object. It has syntactic
  support for collection literals and comprehensions. Custom objects can be
  created using positional and keyword calls that are customized by special
  ``__init__()`` method.

This PEP aims at improving the support for destructuring heterogeneous data
by adding a dedicated syntactic support for it in the form of pattern matching.
On very high level it is similar to regular expressions, but instead of
matching string, it will be possible to match arbitrary Python objects.

We believe this will improve both readability and reliability of relevant code.
To illustrate the readability improvement, let us consider an actual example
from the Python standard library::

  def is_tuple(node):
      if isinstance(node, Node) and node.children == [LParen(), RParen()]:
          return True
      return (isinstance(node, Node)
              and len(node.children) == 3
              and isinstance(node.children[0], Leaf)
              and isinstance(node.children[1], Node)
              and isinstance(node.children[2], Leaf)
              and node.children[0].value == "("
              and node.children[2].value == ")")

With the syntax proposed in this PEP it can be rewritten as below. Note that
the proposed code will work without any modifications to the definition of
``Node`` and other classes here::

  def is_tuple(node: Node) -> bool:
      match node:
      as Node(children=[LParen(), RParen()]):
      as Node(children=[Leaf(value="("), Node(...), Leaf(value=")")]):
          return True
      else:
          return False

See the `syntax`_ sections below for a more detailed specification. From
the reliability perspective, experience shows that missing a case when dealing
with a set of possible data values leads to hard to debug issues, thus forcing
people to add safety asserts like this::

  def get_first(data: Union[int, List[int]]) -> int:
      if isinstance(data, list) and data:
          return data[0]
      elif isinstance(data, int):
          return data
      else:
          assert False, "should never get here"

With the proposed pattern matching such exhaustiveness checks will be added
automatically.

Similarly to how constructing objects can be customized by a user-defined
``__init__()`` method, we propose that destructuring objects can be customized
by a new special ``__match__()`` method. As part of this PEP we specify the
builtin implementation for ``object.__match__()``, match behavior for builtin
collections such as ``tuple``, ``list``, ``dict``, and ``set``, and for
auto-generated flexible ``__match__()`` method for PEP 557 dataclasses. See
`runtime`_ section below.

Finally, we aim to provide a comprehensive support for static type checkers
and similar tools. For this purpose we propose to introduce a
``@typing.sealed`` class decorator that will be idempotent at runtime, but
will indicate to static tools that all subclasses of this class must be defined
in the same module. This will allow effective static exhaustiveness checks,
and together with dataclasses, will provide a nice support for algebraic data
types [2]_. See `static checkers`_ section for more details.

In general, we believe that pattern matching proved to be a useful and
expressive tool in various modern languages. In particular, some aspects of
this PEP were inspired by how pattern matches work in Rust [3]_ and
Scala [4]_.


.. _syntax:

Syntax and Semantics
====================

Match arms
----------

A simplified pseudo-grammar for the proposed syntax is::

    Match = "match" Expression ":" (("as" Pattern ":")+ Suite)+ ["else:" Suite]

We propose the match syntax to be a statement, not expression. Although in
many languages it is an expression, being a statement better suites the general
logic of Python syntax. See `rejected ideas`_ for more discussion. The list of
allowed patterns is specified below in the `patterns`_ subsection.

The ``match`` word is proposed to be a soft keyword, so that it is recognized
as a keyword at the beginning of match statement, but is allowed to be used in
other positions as a variable or argument name.

Note that there can be more than one match arm per match suite. The proposed
indentation structure is as following::

    match some_expression:
    as pattern_1a:
    as pattern_1b:
        ...
    as pattern_2:
        ...
    else:
        ...

Such layout saves an indentation level and matches a common indentation scheme
for ``switch`` statement in C language. Although this may be tricky for some
simple-minded editors, it should be not hard to support in principle, one just
needs to not add indentation level after a colon if the previous line starts
with ``match``.


Match semantics
---------------

The proposed large scale semantics for choosing the match is to choose first
matching pattern and and execute the corresponding suite. The remaining
patterns are not tried. If there are no matching pattens, the ``else`` clause
is executed. If the latter is absent, an instance of ``UnmatchedValue``
(proposed to be a subclass of ``ValueError``) is raised.

Essentially this is equivalent to a chain of ``if ... elif ... else`` except
the default ``else`` clause is to raise an exception. Note that unlike for
``switch`` statement, the pre-computed dispatch dictionary semantics does not
apply here.

Name bindings made during successful pattern match outlive the executed suite
and can be used after the match statement. This follows the logic of other
Python statements that can bind names, such as ``for`` loop and ``with``
statement. For example::

  match shape:
  as Point(x, y):
      ...
  as Rectangle(x, y, _x, _y):
      ...
  print(x, y)  # This works


.. _patterns:

Allowed patterns
----------------

The following patterns are supported:

* Literal pattern, i.e. a simple literal like a string, a number, boolean,
  or None::

    match number:
    as 1:
        print("Just one")
    as 2:
        print("A couple")
    else:
        print("Many")

  Literal pattern uses equality with literal on the right hand side, so that
  in the above example ``number == 1`` and then possibly ``number == 2`` will
  be evaluated.

* Name pattern, that serves as an assignment target for the matched
  expression::

    match greeting:
    as None:
        print("Hello!")
    as name:
        print(f"Hi {name}!")

  Note that name pattern always succeeds. No special meaning is attached to
  names that start with underscores. A name pattern appearing in a scope
  makes this name local to that scope. For example, using ``name`` after
  the above snippet will raise ``UnboundLocalError`` rather than ``NameError``
  if the ``None`` match arm was taken.

* Display pattern is a generalization of iterable unpacking but supports all
  builtin collections: tuples, lists, dictionaries, and sets. Each element
  can be an arbitrary pattern plus there may be at most one ``*name`` or
  ``**name`` pattern to catch all remaining items::

    match collection:
    as (1, x, *other):
        print("Got tuple")
    as [1, [x, *other]]:
        print("Got nested list")
    as {1: x, **other}:
        print("Got dictionary")
    else:
        print("Probably a set")

  For dictionaries and sets the order of items is ignored, so e.g. the result
  of matching ``{1, 2}`` against ``{x, y}`` is unpredictable, but the latter
  will only match a set with two elements.

* Unstructured class pattern is a synonym for an ``isinstance()`` check, it is
  mostly useful in nested positions, when the content of the object is not
  important and it serves just as a marker. For example::

    match shapes:
    as [Point(...), second, third, *other]:
        print(f"Hm, the first one is point, then {second} and {third}")

* Structured class pattern supports two possible ways of matching: by position
  like ``Point(x, y)``, and by name like ``User(id=id, name=name)``. These two
  can be combined, but positional match cannot follow a match by name. Each
  item in a class match can be an arbitrary pattern, plus at most one ``*name``
  or ``**name`` pattern can be present. Semantics of the class pattern is an
  ``isinstance()`` call plus a ``__match__()`` call on the class if the former
  returns ``True``. For example::

    match shape:
    as Point(x, y):
        ...
    as Rectangle(*coordinates, painted=True):
        ...

  This PEP only fully specifies the behavior ``__match__()``
  for ``object`` and dataclasses, custom classes are only required to follow
  the protocol specified in `runtime`_ section. After all, the authors of
  a class know best how to "revert" the logic of the ``__init__()`` they wrote.
  The runtime will then chain these calls to allow matching against arbitrarily
  nested patterns.


Guards
------

Each *top-level* pattern can be followed by a guard of the form
``if expression``. A match arm succeeds if the pattern matches and
the guard evaluates to true. For example::

  match shape:
  as Point(x, y, color) if color == BLACK:
      print("Black point")
  else:
      print("Something else")

Note that having guards is important since names always have store semantics,
i.e. serve as assignment targets. Static languages can easily special case
constants and enums to be used similar to literals, but this is not possible
in Python. An early version of this PEP proposed to support constant patterns
via special syntax or complicated implicit rules, see `rejected ideas`_.

Note that guards are also useful in a much wider range of scenarios, for
example::

  match input:
  as (x, y) if x > MAX_INT and y > MAX_INT:
      print("Got a pair of large numbers")
  as x if x > MAX_INT:
      print("Got a large number")
  else:
      print("Not an outstanding input")

If evaluating a guard raises an exception, it is propagated onwards rather
than fail the match arm. Although name patterns always succeed, all names that
appear in a pattern are bound after the guard succeeds. So this will raise
a ``NameError``::

  values = [0]
  match value:
  as [x] if x:
      ...
  else:
      ...
  x  # NameError here


Coinciding names
----------------

If patterns in match arm contain name patterns with coinciding names, then
all the matched objects must compare equal for the match arm to succeed::

  match sorted(deck):
  as [x, x, y, y, y]:
  as [x, x, x, y, y]:
      print("Got a full house")

When matching against such patterns, all matched values are compared by
a chained (not pairwise) equality for every group, and the lexicographically
left-most value in each group is bound to the name. For example this match::

   match nested:
   as [x, [x, [x, y, y]]]:
       ...

is essentially equivalent to the following expansion with intermediate names
and a guard::

  match nested:
  as [_1, [_2, [_3, _4, _5]]] if _1 == _2 == _3 and _4 == _5:
      x = _1
      y = _4
      ...


Named sub-patterns
------------------

It is often useful to match a sub-pattern *and* to bind the corresponding
value to a name. For example, it can be useful to ensure some sub-patterns
are equal, to write more efficient matches, or simply to avoid repetition.
To simplify such cases, a name pattern can be combined with arbitrary other
pattern using named sub-patterns of the form ``name := pattern``.
For example::

  match get_shape():
  as Line(point := Point(x, y), point):
      print(f"Zero length line at {x}, {y}")

Note that the name pattern used in the named sub-pattern can be used in
the match suite, or after the match statement. Another example::

  match group_shapes():
  as ([], [point := Point(x, y), *other]):
      print(f"Got {point} in the second group at {x}, {y}")
      ...

Technically, most such examples can be rewritten using guards and/or nested
match statements, but this will be less readable and/or will produce less
efficient code. Essentially, most of the arguments in PEP 572 apply here
equally.


One-off matches
---------------

While inspecting some code-bases that may benefit the most from the proposed
syntax, it was found that single arm matches would be used relatively often,
mostly for various special-casing. In other languages this is supported in
the form of one-off matches. We propose to support such one-off matches::

  if match value as pattern:
      ...

as equivalent to the following expansion::

  match value:
  as pattern:
      ...
  else:
      pass  # Note: not raising UnmatchedValue exception here

There will be no ``elif match`` statements allowed. One-off match is special
case of ``match`` statement, not a special case of an ``if`` statement. To
illustrate how this will benefit readability, consider this (slightly
simplified) snippet from real code::

  if isinstance(node, CallExpr):
      if (isinstance(node.callee, NameExpr) and len(node.args) == 1 and
              isinstance(node.args[0], NameExpr)):
          call = node.callee.name
          arg = node.args[0].name
          ...  # Continue special-casing 'call' and 'arg'
  ...  # Follow with generic code

This can be rewritten in a more obvious way as::

  if match node as CallExpr(callee=NameExpr(name=call), args=[NameExpr(name=arg)]):
      ...  # Continue special-casing 'call' and 'arg'
  ...  # Follow with generic code


Similar we propose a ``while match`` shorthand for processing streams of
heterogeneous data where some kind needs special-casing. For example::

  def get_next_data() -> Union[Chunk, Timeout]:
      ...

  while match get_next_data() as Chunk(data, checksum=0):
      ...  # Do something with data


No guards are allowed in one-off matches, their semantics in case off single
match arm can be always represented by the same ``if`` statement put on
a separate line.


.. _runtime:

Runtime specification
=====================

The ``__match__()`` protocol
----------------------------

Depth first

Literals are passed to allow to fail fast.


Impossible matches
-------------------


Default ``object.__match__()``
------------------------------

Use ``__getitem__()`` and ``__getstate__()`` as fallback


Dataclasses
-----------


Builtin classes
---------------

Builtin collections will be special-cased instead of using
``__match__()`` to use efficient code and avoid excessive method
calls.


.. _static checkers:

Static checkers specification
=============================

Exhaustiveness checks
---------------------

PEP 484 specifies exhaustiveness checks for enum values. This PEP
generalize this requirement to arbitrary patterns.


Sealed classes as ADTs
----------------------


Type erasure
------------

``IntQueue = Queue[int]`` should be rejected in unstructured match.
Note this fails at runtime with current implementation of ``typing``
and PEP 585.

In general, generic classes are allowed, if sub-patterns bind
the type variables.


Note about constants
--------------------


Precise type checking of star matches
-------------------------------------

A transform example keeping line and column.


Backwards Compatibility
=======================

This PEP is fully backwards compatible.


Reference Implementation
========================

None yet. If there will be a general positive attitude towards the PEP,
we will start work on implementation soon to iron out possible corner cases
before acceptance.


.. _rejected ideas:

Rejected Ideas
==============

Just allow a more flexible assignment targets
---------------------------------------------

Aka irrefutable matches.
No, because it is not what is commonly needed, people want an ``if``.


Make it an expression
---------------------

No, because it is inconsistent with other things in Python


Use a hard keyword
------------------

Although it would significantly simplify life for simple No, because:

* The new parser doesn't require us to do this.

* ``match`` is so commonly used in existing code


Use a nested indentation scheme
-------------------------------

No, because it can be really long for nested match statements.


Use ``or`` to combine matches
-----------------------------

No, because:

* Can cause ambiguity with guards, also with other operators like ``|``.

* In real life it will be anyway split over multiple lines.

* Using multiple arms is not uncommon in other languages.


Support constant pattern
------------------------

No, because it is too ambiguous. Also use guards or ``if x == BLACK: ...``.


Use dispatch dict semantics for matches
---------------------------------------

No, because it may be very tricky if possible at all (unlike for switch
statement).


Allow fall through without a match
----------------------------------

No, because:

* This can cause subtle bugs.

* It is easy to add an ``else`` match arm.

* Use ad-hoc matches for special cases.


Allow ``elif match`` statements
-------------------------------

No, because there should be only one way to do it. If people will ask about
this, we can always reconsider later.


Ignore underscores in coinciding name match
-------------------------------------------

No, because this is subtle and may be unexpected, instead use ``_1``, ``_2``
etc.


Implement builtin support for matches on ``frozenset``
------------------------------------------------------

No, because supporting this will require complicating the basic
semantics and this will be probably used very rarely. We can reconsider
if people will actually ask about this.


References
==========

.. [1]
   https://en.wikipedia.org/wiki/Pattern_matching

.. [2]
   https://en.wikipedia.org/wiki/Algebraic_data_type

.. [3]
   https://doc.rust-lang.org/reference/patterns.html

.. [4]
   https://docs.scala-lang.org/tour/pattern-matching.html

.. [5]
   https://docs.python.org/3/library/dataclasses.html

.. [6]
   https://docs.python.org/3/library/typing.html


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
